name: Safe Multi-Service Builder

# When this workflow runs
on:
  workflow_dispatch:  # Manual trigger - you control when it runs
    inputs:
      service:
        description: 'Which service to build?'
        required: true
        type: choice
        options:
        - frontend
        - catalogue
        - recommendation
        - voting
      create_pr:
        description: 'Create Pull Request (recommended)'
        type: boolean
        default: true

# Environment variables (like constants)
env:
  REGISTRY: docker.io
  DOCKER_HUB_USERNAME: ${{ secrets.DOCKER_HUB_USERNAME }}
  DOCKER_HUB_TOKEN: ${{ secrets.DOCKER_HUB_TOKEN }}

jobs:
  # First job: Build the Docker image
  build-service:
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      service: ${{ inputs.service }}
    
    steps:
      # Step 1: Get the code
      - name: Checkout main repository
        uses: actions/checkout@v4
      
      # Step 2: Set up Docker
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      # Step 3: Login to Docker Hub
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ env.DOCKER_HUB_USERNAME }}
          password: ${{ env.DOCKER_HUB_TOKEN }}
      
      # Step 4: Clone the service repository
      - name: Clone ${{ inputs.service }} repository
        run: |
          echo "ðŸ”„ Cloning ${{ inputs.service }} repository..."
          
          # Try to clone the repo, exit with clear error if it fails
          if ! git clone https://github.com/shaizshaikh/craftista-${{ inputs.service }}.git service; then
            echo "âŒ Failed to clone craftista-${{ inputs.service }} repository!"
            echo "Make sure the repository exists and is accessible."
            exit 1
          fi
          
          cd service
          echo "âœ… Successfully cloned repository"
          echo "ðŸ“ Current commit: $(git rev-parse --short HEAD)"
      
      # Step 5: Create a proper version number
      - name: Generate version
        id: version
        run: |
          cd service
          
          # Create version based on current date and commit
          DATE=$(date +%Y%m%d)
          COMMIT=$(git rev-parse --short HEAD)
          VERSION="${DATE}-${COMMIT}"
          
          echo "ðŸ·ï¸  Generated version: $VERSION"
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          
          # Also save it as environment variable for next steps
          echo "VERSION=$VERSION" >> $GITHUB_ENV
      
      # Step 6: Check if this version already exists on Docker Hub
      - name: Check if image already exists
        run: |
          echo "ðŸ” Checking if image already exists..."
          IMAGE_TAG="${{ env.DOCKER_HUB_USERNAME }}/craftista-${{ inputs.service }}:${{ env.VERSION }}"
          
          # Try to pull the image (will fail if doesn't exist)
          if docker pull $IMAGE_TAG 2>/dev/null; then
            echo "âš ï¸  Image $IMAGE_TAG already exists!"
            echo "This means this exact commit was already built."
            echo "You can still proceed, but the image will be overwritten."
          else
            echo "âœ… Image doesn't exist yet, good to build!"
          fi
      
      # Step 7: Build and push Docker image
      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: ./service
          push: true
          tags: |
            ${{ env.REGISTRY }}/${{ env.DOCKER_HUB_USERNAME }}/craftista-${{ inputs.service }}:${{ env.VERSION }}
            ${{ env.REGISTRY }}/${{ env.DOCKER_HUB_USERNAME }}/craftista-${{ inputs.service }}:latest
        
      - name: Build success
        run: |
          echo "ðŸŽ‰ Successfully built and pushed:"
          echo "   ðŸ“¦ ${{ env.DOCKER_HUB_USERNAME }}/craftista-${{ inputs.service }}:${{ env.VERSION }}"
          echo "   ðŸ“¦ ${{ env.DOCKER_HUB_USERNAME }}/craftista-${{ inputs.service }}:latest"

  # Second job: Update deployment files (only runs after build succeeds)
  update-deployment:
    needs: build-service
    runs-on: ubuntu-latest
    
    steps:
      # Step 1: Get the main repository code
      - name: Checkout main repository
        uses: actions/checkout@v4
        with:
          # This allows the workflow to push changes
          token: ${{ secrets.GITHUB_TOKEN }}
      
      # Step 2: Create deployment directory if it doesn't exist
      - name: Prepare deployment directory
        run: |
          echo "ðŸ“ Creating deployment directory..."
          mkdir -p deployments/${{ needs.build-service.outputs.service }}
      
      # Step 3: Generate Kubernetes deployment file
      - name: Generate deployment manifest
        run: |
          SERVICE="${{ needs.build-service.outputs.service }}"
          VERSION="${{ needs.build-service.outputs.version }}"
          
          echo "ðŸ“ Generating deployment manifest for $SERVICE..."
          
          cat > deployments/$SERVICE/deployment.yaml << EOF
          # Generated by GitHub Actions on $(date)
          # Service: $SERVICE
          # Version: $VERSION
          
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: craftista-$SERVICE
            labels:
              app: craftista-$SERVICE
              version: "$VERSION"
          spec:
            replicas: 1
            selector:
              matchLabels:
                app: craftista-$SERVICE
            template:
              metadata:
                labels:
                  app: craftista-$SERVICE
                  version: "$VERSION"
              spec:
                containers:
                - name: $SERVICE
                  image: ${{ env.DOCKER_HUB_USERNAME }}/craftista-$SERVICE:$VERSION
                  ports:
                  - containerPort: 8080
                  # Add resource limits for better cluster management
                  resources:
                    requests:
                      memory: "128Mi"
                      cpu: "100m"
                    limits:
                      memory: "256Mi"
                      cpu: "200m"
          ---
          apiVersion: v1
          kind: Service
          metadata:
            name: craftista-$SERVICE-service
            labels:
              app: craftista-$SERVICE
          spec:
            type: ClusterIP
            ports:
              - port: 8080
                targetPort: 8080
                protocol: TCP
            selector:
              app: craftista-$SERVICE
          EOF
          
          echo "âœ… Deployment manifest created!"
      
      # Step 4A: Create Pull Request (Safe option - RECOMMENDED)
      - name: Create Pull Request with changes
        if: ${{ inputs.create_pr }}
        uses: peter-evans/create-pull-request@v5
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          commit-message: "ðŸš€ Deploy ${{ needs.build-service.outputs.service }} version ${{ needs.build-service.outputs.version }}"
          title: "Deploy ${{ needs.build-service.outputs.service }} version ${{ needs.build-service.outputs.version }}"
          body: |
            ## ðŸš€ Deployment Update
            
            **Service:** `${{ needs.build-service.outputs.service }}`
            **Version:** `${{ needs.build-service.outputs.version }}`
            **Docker Image:** `${{ env.DOCKER_HUB_USERNAME }}/craftista-${{ needs.build-service.outputs.service }}:${{ needs.build-service.outputs.version }}`
            
            ### Changes
            - Updated deployment manifest for ${{ needs.build-service.outputs.service }}
            - New Docker image built and pushed successfully
            
            ### Next Steps
            1. Review the deployment manifest
            2. Merge this PR to update the deployment
            3. Apply the manifest to your Kubernetes cluster
            
            ---
            *This PR was created automatically by GitHub Actions*
          branch: deploy/${{ needs.build-service.outputs.service }}-${{ needs.build-service.outputs.version }}
          delete-branch: true
      
      # Step 4B: Direct push to main (Less safe, use only if you're sure)
      - name: Push directly to main
        if: ${{ !inputs.create_pr }}
        run: |
          echo "âš ï¸  Pushing directly to main branch..."
          
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          
          git add deployments/
          
          if git diff --staged --quiet; then
            echo "â„¹ï¸  No changes to commit"
          else
            git commit -m "ðŸš€ Deploy ${{ needs.build-service.outputs.service }} version ${{ needs.build-service.outputs.version }}"
            git push origin main
            echo "âœ… Changes pushed to main"
          fi
      
      # Step 5: Summary
      - name: Deployment summary
        run: |
          echo "## ðŸŽ‰ Deployment Summary"
          echo ""
          echo "**Service:** ${{ needs.build-service.outputs.service }}"
          echo "**Version:** ${{ needs.build-service.outputs.version }}"
          echo "**Docker Image:** ${{ env.DOCKER_HUB_USERNAME }}/craftista-${{ needs.build-service.outputs.service }}:${{ needs.build-service.outputs.version }}"
          echo ""
          if [ "${{ inputs.create_pr }}" = "true" ]; then
            echo "**Action:** Pull Request created for review"
            echo "**Next Step:** Review and merge the PR"
          else
            echo "**Action:** Deployment manifest updated in main branch"
            echo "**Next Step:** Apply the manifest to your cluster"
          fi
          echo ""
          echo "**Deployment file location:** deployments/${{ needs.build-service.outputs.service }}/deployment.yaml"